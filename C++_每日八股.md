## C++

### 0321

#### template

**编译**器在遇到模板函数定义时，并不会立即将其编译为可执行代码，而是将其视为一种代码生成工具。在编译器遇到**模板函数的调用时**，它会根据传递给函数的实际类型来实例化模板函数，生成对应的代码。

如果需要**多次调用模板函数**，编译器可能会**多次进行模板实例化**，但每次实例化都会生成独立的代码，从而保证了代码的灵活性和效率。

#### 移动语义和完美转发

移动构造函数和移动赋值运算符通常会将被移动对象的指针或资源转移给新的对象，并将被移动对象置为无效状态。这样做不仅可以避免不必要的内存分配和拷贝操作，还可以减少对象的内存占用和提高对象的生命周期控制。

完美转发是指在函数中传递参数时，将**参数的类型和值保持不变地转发给其他函数**，从而避免了额外的拷贝和类型转换，提高了代码的灵活性和可维护性。（右值引用参数仍然为左值，完美转发可以保留原有的类型和值）

#### 智能指针

unique_ptr是一个**删除了拷贝构造函数**、保留了移动构造函数的指针封装类型，不能与其它unique_ptr类型的指针对象共享所指对象的内存。

release或reset将指针的所有权从一个(非const)unique_ptr转移给另一个unique。

make_shared 是为了避开两次创建的过程，因为shared_ptr 中有计数控制。而unique_ptr 中并没有类似的，**所以make_unique 可有可无**。

shared_ptr 初始化数据成员`_M_use_count`，`_M_weak_count`(用于weak_ptr)。

1. 所属权转移的语义不同：

`std::auto_ptr` 是一种独占式的智能指针，拥有指向动态分配对象的独占所有权，它的所有权可以被转移给另一个 `std::auto_ptr`，但是它不能被放入标准库的容器中，因为容器需要进行复制和赋值，而 **`std::auto_ptr` 的拷贝构造函数和赋值操作符都会转移所有权。**

`std::unique_ptr` 也是一种独占式的智能指针，拥有指向动态分配对象的独占所有权，但它的**拷贝构造函数和赋值操作符都被删除了**，因此不能进行拷贝和赋值操作。但是，可以将 `std::unique_ptr` 放入标准库的容器中，因为容器中的元素**可以进行移动语义**的操作。

2. 支持不同的删除器：

`std::auto_ptr` 只支持 delete 操作符作为删除器，而 `std::unique_ptr` 可以**支持不同的删除器**。当使用 `std::unique_ptr` 指向的**对象的类型不是以 delete 操作符来销毁时，可以通过提供自定义删除器来销毁对象**。

#### 虚函数与虚函数表

虚函数的实现依赖于虚函数表（Virtual Function Table，简称 VTable）。**虚函数表是一个指针数组**，每个元素指向一个虚函数的地址。当一个类中定义了一个或多个虚函数时，编译器会在该类的虚函数表中为每个虚函数添加一个条目，这个条目保存了虚函数的地址。

当派生类重写基类的虚函数时，编译器会在派生类的虚函数表中修改对应虚函数的地址，指向派生类中的实现。在运行时，如果使用**基类的指针或引用调用虚函数，会根据该指针或引用所指向的对象的实际类型，在虚函数表中查找对应虚函数的地址，然后调用该地址指向的虚函数的实现。**

tips：需要注意的是，**虚函数表是每个对象所独有的**，而不是整个类共享的。每个对象都有自己的虚函数表指针，指向该对象所属的类的虚函数表。

在对象构造的过程中，**对象的虚函数表还没有完全构建完成**，因此无法在构造函数中使用虚函数，初始化完毕，才能构建虚函数表。

#### C++ vs. C

1. 编程范式：C++ 是一门**支持面向对象编程**的语言，可以使用类、继承、封装、多态等特性。而 C 语言则是一门面向过程的编程语言，重点在于**函数的调用和模块化设计**。
2. 扩展性：C++ 是在 C 语言的基础上发展而来的，因此 C++ 具有更高的扩展性和灵活性。C++ 提供了诸多的高级特性，如模板、STL、异常处理、重载运算符等，使得 C++ 可以更好地适应不同的开发需求。而 C 语言虽然具有较好的可移植性，但**扩展性较差，缺少了很多现代编程语言的高级特性**。
3. 内存管理：C++ 提供了一套完整的内存管理机制，包括**自动、手动、共享和智能**等多种内存管理方式，使得 C++ 能够更好地应对复杂的内存管理需求。而 C 语言的内存管理则相对简单，主要通过**手动分配和释放内存**来完成。
4. 异常处理：C++ 提供了异常处理机制，可以更好地处理程序运行时的错误。而 **C 语言则没有提供异常处理机制，程序运行时的错误只能通过返回值等方式来处理**。
5. 标准库：C++ 标准库比 C 标准库更加完整和强大，包含了大量的库函数和容器类型，使得 C++ 可以更好地处理字符串、容器、算法等问题。而 **C 语言的标准库相对简单，主要包含了一些基本的库函数和类型**。
6. 编译器：C++ 的编译器通常比 C 语言的编译器更加复杂，因为 C++ 支持更多的特性和语法。同时，C++ 的编译器也需要更多的时间来完成编译和优化。

---

#### 单继承 多继承 虚继承的虚函数

单继承

- 虚表中派生类覆盖的虚函数的地址被放在了基类相应的函数原来的位置
- 派生类没有覆盖的虚函数就延用基类的。同时，虚函数按照其声明顺序放于表中，父类的虚函数在子类的虚函数前面。

多继承

每个基类**都有自己的虚函数表**
派生类的虚函数地址存依照声明顺序放在**第一个基类的虚表最后**

当我们直接通过**父类指针调用子类中的未覆盖父类的成员函数**，编译器会报错，但通过实验，我们可以用对象的地址访问到各个子类的成员函数，就违背了C++语义，操作会有一定的隐患，当我们使用时要注意这些危险的东西！

虚继承 **解决菱形继承**

虚继承的基类共享一个虚表。等价于单继承

---

#### 纯虚函数

**什么情况下使用纯虚函数？**
　　1、当想在基类中抽象出一个方法，且该基类只做能被继承，而不能被实例化；
　　2、这个方法必须在派生类（derived class）中被实现。

**作用：**允许我们定义抽象基类和接口，以及提供默认实现。在设计类层次结构时，使用纯虚函数可以使**代码更加模块化、灵活和易于维护**。

---

#### 类的大小

不考虑虚函数的情况下，类的大小等于其成员变量大小的总和，其中每个成员变量的大小是由其类型和对齐方式决定的。**对于一个类，其大小必须是其最宽成员变量大小的倍数**，因为编译器会将类的实例分配到内存的地址上，以使得每个成员变量的地址对齐。

考虑虚函数的情况下，类的大小会增加一个指针大小，这个指针指向虚函数表。**虚函数表是一个包含类的虚函数指针的数组，它用于支持多态性，即在运行时调用派生类的虚函数。虚函数表的大小取决于类中的虚函数数量和编译器的实现。**

---

#### 为什么free不需要传参

由 new 运算符在分配内存时存储的，它通常是存储在内存块的前几个字节中的。因此，当 delete 运算符被调用时，它可以**自动地读取这个大小信息，并将其用于释放内存**。

---

#### auto decltype

auto：让编译器根据**变量初始化的表达式**来推断变量的类型。

decltype：作用是获取表达式的类型。**不会执行表达式，而只会根据表达式推导出其类型，因此即使表达式是不合法的，也可以使用 `decltype` 推导出其类型**，例如：`decltype(std::declval<int>() + std::declval<double>())`。

---

#### array 和 数组 （传递问题）

使用 `std::array` 可以提高代码的可读性和安全性，**避免数组越界、类型不匹配**等问题。同时，由于 `std::array` 是一个容器，**可以方便地进行拷贝和赋值**，而且**对于大型数组的传递**，使用 `std::array` 通常比使用裸指针**更加安全和易于维护**。

普通数组则是 C++ 的基本数据结构之一，使用简单、高效，可以直接操作内存，**不需要额外的空间开销**。但是，普通数组的长度是固定的，不能动态调整，而且对于**大型数组的传递，需要手动管理内存和长度信息，容易出现越界和内存泄漏等问题**。

tips：数组可以有符号下标访问，a[-2]也是正确的。

---

#### resize vs. reserve

resize：**改变容器大小**，多出来的元素会被默认初始化为 0，当容器大小增大时，会增加内存开销，**当容器大小减小时，不会释放内存**

reserve：**预留容器的内存空间，但并不改变容器的大小**，预留容器能够容纳 10 个元素的内存空间，但是此时容器大小仍为 0，需要使用 `push_back` 等函数将元素添加到容器中。

---

#### clear

`clear()` 来清空容器中的所有元素，即**将容器的大小设为 0**。清空容器可以通过释放内存、避免出现悬空指针和避免内存泄漏等问题，特别是在需要重复使用容器或者需要将容器作为成员变量时，清空容器可以避免对已有的数据产生干扰。

需要注意的是，**清空容器并不会改变容器的容量大小，如果需要释放容器的内存空间，可以使用 `std::vector<int>(v).swap(v)` 或者 `std::vector<int>().swap(v)`** 这样的语句来清空容器并释放其占用的内存空间。

---

#### 类型转换

1. static_cast:
   1. 非多态类型转换
   2. 不执行类型检查
   3. 基本类型转换
   4. 子类转化为父类安全（向上转换），父类转化为子类不安全（因为子类可能有不在父类的字段或方法）
2. dynamic_cast:
   1. 多态类型转换
   2. 执行行运行时类型检查
   3. **只适用于指针或引用**
   4. 转换将失败（返回 nullptr），但不引发异常
   5. 在整个类层次结构中移动指针，包括向上转换、向下转换
3. const_cast:
   1. 用于删除 const、volatile 和 __unaligned 特性（如将 const int 类型转换为 int 类型 ）
4. reinterpret_cast:
   1. 用于位的简单重新解释
   2. 滥用 reinterpret_cast 运算符可能很容易带来风险。 除非所需转换本身是低级别的，否则应使用其他强制转换运算符之一。
   3. 允许将任何指针转换为任何其他指针类型（如 `char*` 到 `int*` 或 `One_class*` 到 `Unrelated_class*` 之类的转换，但其本身并不安全）
   4. 也允许将任何整数类型转换为任何指针类型以及反向转换。
   5. reinterpret_cast 运算符不能丢掉 const、volatile 或 __unaligned 特性。
   6. reinterpret_cast 的一个实际用途是在哈希函数中，即，通过让两个不同的值几乎不以相同的索引结尾的方式将值映射到索引。

---

#### 堆排序

```
#include <iostream>
#include <algorithm>

using namespace std;

// 用于维护最大堆的函数
// i: 当前节点的下标
void heapify(int arr[], int n, int i) {
    int largest = i; // 假设当前节点的值最大
    int l = 2*i + 1; // 当前节点的左孩子节点下标
    int r = 2*i + 2; // 当前节点的右孩子节点下标

    // 如果左孩子节点的值比当前节点大，那么左孩子节点就是最大值
    if (l < n && arr[l] > arr[largest]) {
        largest = l;
    }

    // 如果右孩子节点的值比当前节点和左孩子节点都大，那么右孩子节点就是最大值
    if (r < n && arr[r] > arr[largest]) {
        largest = r;
    }

    // 如果当前节点不是最大值，则交换当前节点和最大值的位置，并继续维护最大堆
    if (largest != i) {
        swap(arr[i], arr[largest]);
        heapify(arr, n, largest);
    }
}

// 堆排序函数
void heapSort(int arr[], int n) {
    // 首先构建最大堆
    for (int i = n / 2 - 1; i >= 0; i--) {
        heapify(arr, n, i);
    }

    // 逐步将最大元素交换到数组的末尾，并重建最大堆
    for (int i = n - 1; i >= 0; i--) {
        swap(arr[0], arr[i]);
        heapify(arr, i, 0);
    }
}

int main() {
    int arr[] = {12, 11, 13, 5, 6, 7};
    int n = sizeof(arr)/sizeof(arr[0]);

    heapSort(arr, n);

    cout << "Sorted array is \n";
    for (int i=0; i<n; ++i) {
        cout << arr[i] << " ";
    }
    cout << endl;
}

```

---

#### 快速排序

```
#include <iostream>
#include <algorithm>

using namespace std;

// 快速排序递归函数
void quickSort(int arr[], int low, int high) {
    if (low < high) { 1 2 4 5 1 3
        // 将数组分成两部分
        int pivot = arr[high]; // 选取最后一个元素作为基准元素
        int i = low - 1; // i 为小于基准元素的部分的最后一个元素的下标

        for (int j = low; j <= high - 1; j++) { // j 为遍历整个数组的指针
            if (arr[j] < pivot) { // 如果当前元素小于基准元素
                i++; // i 的下标向右移动一个位置
                swap(arr[i], arr[j]); // 将当前元素交换到小于基准元素的部分的末尾
            }
        }
        swap(arr[i + 1], arr[high]); // 将基准元素放在正确的位置上

        // 递归地对左右两部分进行排序
        quickSort(arr, low, i); // 对小于基准元素的部分递归调用快速排序
        quickSort(arr, i + 2, high); // 对大于等于基准元素的部分递归调用快速排序
    }
}

int main() {
    int arr[] = {10, 7, 8, 9, 1, 5};
    int n = sizeof(arr) / sizeof(arr[0]);

    quickSort(arr, 0, n - 1); // 调用快速排序算法

    cout << "Sorted array is \n";
    for (int i = 0; i < n; ++i) {
        cout << arr[i] << " ";
    }
    cout << endl;

    return 0;
}

```

---

#### 析构函数调用

1. 生命周期到了
2. delete
3. 容器中清除
4. 对象被创建在栈上，当它的作用域结束时，会自动调用析构函数
5. 对象被创建在全局或静态存储区域中，当程序结束时会自动调用析构函数

---

