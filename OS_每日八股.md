## OS_每日八股

### 0321

#### 字节对齐

---

数据存储在内存的自然边界上，即按照数据类型大小的整数倍进行存储。避免需要访问两次

1. 性能下降：不进行字节对齐会导致内存访问变慢，增加了额外的 CPU 开销和内存访问延迟，从而降低程序性能。
2. 数据损坏：对于某些体系结构，不进行字节对齐可能会导致数据损坏。例如，在某些 ARM 架构的处理器中，未对齐的内存访问可能会触发硬件异常，并导致程序崩溃。
3. 兼容性问题：不同的体系结构和编程语言可能有不同的字节对齐规则，如果数据不进行字节对齐可能会导致兼容性问题。例如，在网络通信中，如果数据不进行字节对齐，可能会导致数据解析错误，从而导致通信失败。

#### cache line 对齐

----

**因为缓存一致性，cache line 上锁，如果不对齐，导致其它数据被锁住。**

---

#### 进程通信

1. 管道（Pipe）：管道是一种半双工的通信方式，通常用于具有父子关系的进程间通信。管道可以使用 `pipe()` 系统调用创建，一个进程将数据写入管道，另一个进程从管道中读取数据。
2. 命名管道（Named Pipe）：命名管道也是一种半双工的通信方式，与管道不同的是，它可以在不同的进程之间进行通信。命名管道可以使用 `mkfifo()` 系统调用创建，进程通过打开命名管道的文件来进行数据交换。
3. 共享内存（Shared Memory）：共享内存是一种最快的进程间通信方式，它允许多个进程访问同一块物理内存区域，从而实现数据共享。共享内存可以使用 `shmget()` 和 `shmat()` 系统调用创建和访问。
4. 消息队列（Message Queue）：消息队列是一种存放消息的链表，多个进程可以通过它来发送和接收消息。消息队列可以使用 `msgget()`、`msgsnd()` 和 `msgrcv()` 系统调用创建和操作。**需要用户态和内核态切换，同时通信的信息不能太大。**
5. 信号（Signal）：信号是一种异步通信方式，用于通知进程发生了某个事件。一个进程可以通过发送信号来通知另一个进程，另一个进程可以通过信号处理函数来处理该信号。kill -9 杀死
6. 套接字（Socket）：套接字是一种全双工的通信方式，可以用于不同计算机之间的进程通信。套接字可以使用 `socket()`、`bind()`、`listen()`、`accept()`、`connect()` 和 `send()`、`recv()` 等系统调用创建和操作。分为IPv4、IPv6、本地的通信，TCP和UDP的方式。write() read() 读写。

#### 线程通信

1. 锁机制（Mutex）：锁机制是一种最基本的线程同步方式，它可以保证多个线程访问同一块临界区代码时的互斥性。线程在访问共享数据之前获取锁，访问完成之后释放锁，其他线程需要等待锁释放后才能访问共享数据。锁机制可以使用 `pthread_mutex_t` 等相关库函数实现。
2. 条件变量（Condition Variable）：条件变量是一种线程间同步的高级机制，它可以让一个或多个线程在满足特定条件之前进入等待状态。当满足条件时，等待的线程被唤醒并继续执行。条件变量可以使用 `pthread_cond_t` 等相关库函数实现。
3. 信号量（**Semaphore**）：信号量是一种计数器，它用于控制多个线程对共享资源的访问。当信号量值为 0 时，等待线程会被阻塞，当信号量值大于 0 时，线程可以访问共享资源并将信号量减 1。信号量可以使用 `sem_t` 等相关库函数实现。
4. 屏障（Barrier）：屏障是一种同步机制，它可以让多个线程在某个点上阻塞等待，直到所有线程都到达这个点之后才能继续执行。屏障可以使用 `pthread_barrier_t` 等相关库函数实现。
5. 原子操作（Atomic Operation）：原子操作是一种不可分割的操作，它可以保证在多线程环境下对共享变量的操作是原子的，不会发生竞争和冲突。原子操作可以使用 `__atomic_` 等相关库函数实现。

---

#### 孤儿进程 僵尸进程

##### 孤儿进程：

一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将**被init进程(进程号为1)所收养**，并由init进程对它们完成状态收集工作。

##### 僵尸进程：

一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。**需要把父进程干了。**

---

#### 进程上下文

CPU 寄存器和程序计数是 CPU 在运行任何任务前，所必须依赖的环境，这些环境就叫做 **CPU 上下文**

CPU 上下文切换就是先把前一个任务的 CPU 上下文（CPU 寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。

系统内核会存储保持下来的上下文信息，当此任务再次被分配给 CPU 运行时，CPU 会重新加载这些上下文，这样就能保证任务原来的状态不受影响，让任务看起来还是连续运行。

上面说到所谓的「任务」，主要包含进程、线程和中断。所以，可以根据任务的不同，把 CPU 上下文切换分成：**进程上下文切换、线程上下文切换和中断上下文切换**。

**交换的信息保存在进程的 PCB**，当要运行另外一个进程的时候，我们需要从这个进程的 PCB 取出上下文，然后恢复到 CPU 中

上下文切换：

1. **用户空间到内核空间的切换**，进程的切换只能由内核态来管理和调度
   1. 保留用户态现场（上下文、寄存器、用户栈等）
   2. 复制**用户态参数**，用户栈切到内核栈，进入内核态
   3. 额外的检查（因为内核代码对用户不信任）
   4. 执行内核态代码
   5. **复制内核态代码执行结果**，回到用户态
   6. 恢复用户态现场（上下文、寄存器、用户栈等）
2. 进程本身的数据结构庞大。Linux 中使用数据结构 **`task_struct`** 来描述进程所有的资源，其主要成员有进程状态、内核栈信息、进程使用状态、PID、优先级、锁、时间片、队列、信号量、内存管理信息、文件列表等等与进程管理、调度密切相关的信息。当切换进程运行，这些数据结构也需要保存和恢复。
3. 虚拟内存。**页表+TLB**。

---

#### 条件变量

用于获得锁的条件，**将一些未满足条件的临界区代码阻塞，避免它们频繁获得锁并释放锁却什么事都没做。**

配合互斥锁使用

---

#### 线程上下文

线程是不是属于同一个进程：

- 当**两个线程不是属于同一个进程，则切换的过程就跟进程上下文切换一样**；
- **当两个线程是属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据**；

---

#### 互斥锁和自旋锁

互斥锁会有**两次线程上下文切换的成本**：

- 当线程加锁失败时，内核会把线程的状态从「运行」状态设置为「睡眠」状态，然后把 CPU 切换给其他线程运行；
- 接着，当锁被释放时，之前「睡眠」状态的线程会变为「就绪」状态，然后内核会在合适的时间，把 CPU 切换给该线程运行。

**如果你能确定被锁住的代码执行时间很短，就不应该用互斥锁，而应该选用自旋锁，否则使用互斥锁。**

**自旋锁**在「用户态」完成加锁和解锁操作，不会主动产生线程上下文切换，所以相比互斥锁来说，会快一些，开销也小一些。

一般加锁的过程，包含两个步骤：

- 第一步，查看锁的状态，如果锁是空闲的，则执行第二步；
- 第二步，将锁设置为当前线程持有；

**CAS 函数**就把这两个步骤合并成一条硬件级指令，形成**原子指令**，这样就保证了这两个步骤是不可分割的，要么一次性执行完两个步骤，要么两个步骤都不执行。

使用自旋锁的时候，当发生多线程竞争锁的情况，加锁失败的线程会「忙等待」，直到它拿到锁。这里的「忙等待」可以用 `while` 循环等待实现，不过最好是使用 CPU 提供的 `PAUSE` 指令来实现「忙等待」，因为可以减少循环等待时的耗电量。

自旋锁是最比较简单的一种锁，一直自旋，利用 CPU 周期，直到锁可用。**需要注意，在单核 CPU 上，需要抢占式的调度器（即不断通过时钟中断一个线程，运行其他线程）。否则，自旋锁在单 CPU 上无法使用，因为一个自旋的线程永远不会放弃 CPU。**

自旋锁与互斥锁使用层面比较相似，但实现层面上完全不同：**当加锁失败时，互斥锁用「线程切换」来应对，自旋锁则用「忙等待」来应对**。

#### 读写锁

根据实现的不同，读写锁可以分为「读优先锁」和「写优先锁」。

**「读优先锁」**的工作方式是：当读线程 A 先持有了读锁，写线程 B 在获取写锁的时候，会被阻塞，并且在阻塞过程中，后续来的读线程 C 仍然可以成功获取读锁，最后直到读线程 A 和 C 释放读锁后，写线程 B 才可以成功获取写锁。写饥饿

**「写优先锁」**当读线程 A 先持有了读锁，写线程 B 在获取写锁的时候，会被阻塞，并且在阻塞过程中，后续来的读线程 C 获取读锁时会失败，于是读线程 C 将被阻塞在获取读锁的操作，这样只要读线程 A 释放读锁后，写线程 B 就可以成功获取写锁。读饥饿

**元数据锁**（MDL）。

我们不需要显示的使用 MDL，因为当我们对数据库表进行操作时，会自动给这个表加上 MDL：

- 对一张表进行 CRUD 操作时，加的是 **MDL 读锁**；
- 对一张表做结构变更操作的时候，加的是 **MDL 写锁**；

**MDL锁是写优先锁**。

**「公平读写锁」**比较简单的一种方式是：用队列把获取锁的线程排队，不管是写线程还是读线程都按照先进先出的原则加锁即可，这样读线程仍然可以并发，也不会出现「饥饿」的现象。

---

#### 乐观锁 悲观锁

互斥锁、自旋锁、读写锁，都是属于悲观锁。

乐观锁做事比较乐观，它假定冲突的概率很低，它的工作方式是：**先修改完共享资源，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作**。

放弃后如何重试，这跟业务场景息息相关，虽然重试的成本很高，但是冲突的概率足够低的话，还是可以接受的。

可见，乐观锁的心态是，不管三七二十一，先改了资源再说。另外，你会发现**乐观锁全程并没有加锁，所以它也叫无锁编程**。

我们常见的 SVN 和 Git 也是用了乐观锁的思想，先让用户编辑代码，然后提交的时候，通过版本号来判断是否产生了冲突，发生了冲突的地方，需要我们自己修改后，再重新提交。

---

#### **一个进程最多可以创建多少个线程**

两个东西有关系：

- **进程的虚拟内存空间上限**，因为创建一个线程，操作系统需要为其分配一个栈空间，如果线程数量越多，所需的栈空间就要越大，那么虚拟内存就会占用的越多。
- **系统参数限制**，虽然 Linux 并没有内核参数来控制单个进程创建的最大线程个数，但是有系统级别的参数来控制整个系统的最大线程个数。

系统的限制，比如下面这三个内核参数的大小，都会影响创建线程的上限：

- ***/proc/sys/kernel/threads-max***，表示系统支持的最大线程数，默认值是 `14553`；
- ***/proc/sys/kernel/pid_max***，表示系统全局的 PID 号数值的限制，每一个进程或线程都有 ID，ID 的值超过这个数，进程或线程就会创建失败，默认值是 `32768`；
- ***/proc/sys/vm/max_map_count***，表示限制一个进程可以拥有的VMA(虚拟内存区域)的数量，具体什么意思我也没搞清楚，反正如果它的值很小，也会导致创建线程失败，默认值是 `65530`。