## Java

### 基础上

---

#### java特点？

1. **平台无关性**（JVM）
2. 多线程（C++ **\C++11引入了/** 没有内置多线程（用户空间，1对多），必须调用操作系统的多线程功能）
3. 面向对象（单继承，封装，多态）
4. **编译解释共存**
5. 支持网络编程

---

#### JVM vs. JDK vs. JRE

##### JVM

1. 虚拟机，运行java字节码，针对不同系统有不同的实现，可以运行相同的字节码，**相同的字节码 + 不同的JVM = 相同的结果**。
2. **只要满足 JVM 规范**，用户可以自己开发专属JVM，例如HotSpot JVM，J9 jVM， Zing VM等。

##### JDK

1. Java开发工具包，有Javac编译器、Javadoc文档工具，Jdb调试工具等。
2. 需要**编程**则需要JDK，或者需要编译成java时需要JDK(**例如JSP 编译成 Java Servlet**)

##### JRE

1. Java 运行时环境，运行**已编译 Java 程序**所需的所有内容的集合，包括 **Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。**
2. 它**不能用于创建**新程序。

---

#### 字节码

1. 即**.class文件，JVM能够理解的代码**，只面向JVM。
2. 保留了解释型语言可移植的特点，**无须重新编译**。
3.  JVM **类加载器首先加载字节码文件**，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢
4. JIT（just-in-time compilation） 编译器，而 JIT 属于**运行时编译**。当 JIT 编译器完成第一次编译后，其会将**字节码对应的机器码保存下来，下次可以直接使用**。
5. **JDK 9 引入了一种新的编译模式 AOT**(Ahead of Time Compilation)，它是直接将**字节码编译成机器码**
6. 为了**支持类似的动态特性**，所以选择使用 JIT 即时编译器。（内存运行时生成字节码，不适合AOT提前编译）。

---

#### 编译与解释并存？

这是因为 Java 语言既具有编译型语言的特征，也具有解释型语言的特征。因为 Java 程序要经过**先编译，后解释两个步骤**，由 Java 编写的程序需要先经过编译步骤，生成字节码（`.class` 文件），这种字节码必须由 Java 解释器来解释执行。

---

#### Oracle JDK vs. OpenJDK

前者是闭源后者开源，二者代码差不多，前者更加稳定，近版本商业付费，私用免费。

前者大概6个月一个版本，后者3个月一个版本。

后者是前者派生的。

前者性能更好。

---

#### Java vs. C++

1. 无指针，内存安全
2. 类是单继承，接口多继承
3. 自动内存回收
4. 不支持操作符重载

---

#### 关键字 vs. 标识符

1. 所有关键字小写；

2. default JDK8 引入默认方法；很特殊，既属于程序控制，也属于类，方法和变量修饰符，还属于访问控制。

3. 在程序控制中，当在 `switch` 中匹配不到任何情况时，可以使用 `default` 来编写默认匹配的情况。

   在类，方法和变量修饰符中，从 JDK8 开始引入了默认方法，可以使用 `default` 关键字来定义一个方法的默认实现。

   在访问控制中，如果一个方法前没有任何修饰符，则默认会有一个修饰符 `default`，但是这个修饰符加上了就会报错

4. double float 不支持 移位运算符。

---

#### 变量

---

##### 成员 vs. 局部？

**语法形式** ：从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 `public`,`private`,`static` 等修饰符所修饰，而局部变量不能被访问控制修饰符及 **`static`** 所修饰；但是，成员变量和局部变量都能被 **`final`** 所修饰。

**存储方式** ：从变量在内存中的存储方式来看,如果成员变量是使用 `static` 修饰的，那么这个成员变量是属于类的，如果没有使用 `static` 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。

**生存时间** ：从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。

**默认值** ：从变量是否有默认值来看，成员变量如果没有被赋初始值，则会自动**以类型的默认值而赋值**（一种情况例外:**被 `final` 修饰的成员变量也必须显式地赋值**），而局部变量则不会自动赋值。

---

##### 静态变量有什么作用？

静态变量可以被类的所有实例共享。无论一个类创建了多少个对象，它们都共享同一份静态变量。

通常情况下，静态变量会被 `final` 关键字修饰成为常量。

---

##### 字符型常量和字符串常量的区别?

1. **形式** : 字符常量是单引号引起的一个字符，字符串常量是双引号引起的 0 个或若干个字符。
2. **含义** : 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)。
3. **占内存大小** ： 字符常量只占 2 个字节; 字符串常量占若干个字节。

(**注意： `char` 在 Java 中占两个字节**)

---

#### 重载 vs. 重写

1. 重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。**编译期。**
2. 重写发生在**运行期**，是**子类对父类的允许访问的方法的实现过程进行重新编写**。
   1. 方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等（**指的是子类或者本类，不是基本数据类型**），抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。**两同两小一大**
   2. **如果父类方法访问修饰符为 `private/final/static` 则子类就不能重写该方法，但是被 `static` 修饰的方法能够被再次声明。**
   3. **构造方法无法被重写**。

---

#### 可变长参数

1. 只能最后一个
2. **遇到方法重载的情况**会优先匹配**固定参数**的方法，因为固定参数的方法匹配度更高。
3. 编译后在.class里，其实是个数组，String... args === String[] args。

---

#### 基本数据类型

1. 8个
2. 6个数字：byte、short、int、long（1，2，4，8），浮点double、float（4，8）；
3. 1个字符：char（2字节）
4. 1个布尔：boolean（1个字节）。
5. long **Java 里使用 `long` 类型的数据一定要在数值后面加上 L，否则将作为整型解析。**
6. 八种基本类型都有对应的包装类分别为：`Byte`、`Short`、`Integer`、`Long`、`Float`、`Double`、`Character`、`Boolean` 。
7. **基本类型有默认值**
8. **基本数据类型存放在栈中是一个常见的误区！** 基本数据类型的**成员变量**如果没有被 `static` 修饰的话（不建议这么使用，应该要使用基本数据类型对应的包装类型），**就存放在堆中**。

#### 基本类型和包装类型的区别？

- 成员变量包装类型不赋值就是 `null` ，而基本类型有默认值且不是 `null`。
- 包装类型**可用于泛型**，而基本类型不可以。
- 基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 `static` 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道**几乎所有对象实例都存在于堆中**。
- 相比于对象类型， 基本数据类型占用的空间非常小。

---

#### 包装类缓存

1. Byte、Short、Integer、Long都会缓存-128到127的实例，当发生装箱例如Integer a = 40;时，a其实是缓存的实例对象，而在超出缓存范围的对象则会重新创建，这时==判断则是false
2. 比较值强制要求使用equals()。

##### 装箱与拆箱

基本-》包装 Integer i = 10;  //装箱 等价于 `Integer i = Integer.valueOf(10)`

包装-》基本 int n = i;   //拆箱 等价于 `int n = i.intValue()`;

tips：**如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。**

#### 浮点和大整形

BigDecimal 避免浮点数计算有误

BigInteger 能够完成大数计算

---

### 基础中

---

#### 面向对象 vs. 面向过程

前者抽象出对象在让对象执行方法，后者则是拆解成连续的方法。

---

#### 创建对象？

1. new 创建
2. 对象在堆，引用在栈
3. 一个引用对应0到一个对象，一个对象对应多个引用

---

#### 对象相等 vs. 引用相等

1. 对象相等等价于对象的内容相等（比地址内的内容）
2. 引用相等，引用指向的内存的地址相等（比地址）

---

#### 类的构造方法

##### 特点

1. 与类同名
2. 无返回值
3. 自动调用
4. 不能重写

##### 作用

初始化类对象

##### 默认？

具有默认构造函数，**当用户定义构造函数之后，将不再添加默认构造函数**，因此强烈建议用户自己编写无参构造函数，避免出现初始化问题。

---

#### 面向对象三大特征

##### 封装

封装是指把一个对象的状态信息（也就是**属性**）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。就好像我们看不到挂在墙上的空调的内部的零件信息（也就是属性），但是可以通过遥控器（方法）来控制空调。

##### 继承

继承是**使用已存在的类的定义作为基础建立新类的技术**，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但**不能选择性地继承父类**。通过使用继承，可以快速地创建新的类，可以提高代码的**重用**，程序的**可维护性**，节省大量创建新类的时间 ，提高我们的开发效率。

**重要知识：**

1. 子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的**私有属性和方法子类是无法访问**，**只是拥有**。
2. 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。
3. 子类可以用自己的方式实现父类的方法。

##### 多态

表示一个对象具有多种的状态，具体**表现为父类的引用指向子类的实例**。

1. 对象类型和引用类型之间具有继承（类）/实现（接口）的关系；
2. 引用类型变量发出的方法调用的到底是哪个类中的方法，**必须在程序运行期间才能确定**；
3. 多态不能调用“只在子类存在但在父类不存在”的方法；
4. 如果**子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法**。

---

#### 接口 vs. 抽象类

##### 区别：

1. 接口是辐射式设计，例如报警器，当报警器的代码改变（触发报警的方式，即输入参数或者返回值），所有的场景的报警器都要改变。
2. 抽象类式模板式设计，我们使用模板在获取通用部分，而修改模板上的个人部分从而完成模板的使用，例如同一个PPT，我将xx大学修改为湖南大学，而其他人修改为福州大学，其余的目录和标题都是公用，这时当我修改这些部分，只需修改模板即可。
3. 接口是一种行为抽象，例如fly，而抽象类是事物抽象，例如飞机，当我们需要战斗机时可以继承飞机，同时实现战斗这个行为。
4. 接口方法只有定义（JDK1.8 default方法包含实现），抽象类可以有抽象方法和普通方法。
5. 接口的所有方法必须实现，抽象类的抽象方法必须实现（抽象类可以没有抽象方法），抽象方法只会出现在抽象类中（对于类而言）。
6. 接口变量必须以public static final 修饰并定义，没有其它的静态代码和方法（JDK 8 后有静态方法）。
7. 抽象类的方法是public protected的，默认public（注意private的方法，子类拥有但是不能实现和使用）。

##### 相同：

- 都不能被实例化。
- 都可以包含抽象方法。
- 都可以有默认实现的方法（Java 8 可以用 `default` 关键字在接口中定义默认方法）。

---

#### 深拷贝、浅拷贝和引用拷贝区别？

![浅拷贝、深拷贝、引用拷贝示意图](https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/basis/shallow&deep-copy.png)

1. 引用拷贝：同一对象
2. 浅拷贝，新对象，对象内部引用同一对象
3. 深拷贝，新对象，对象内部对象是新建对象

---

#### Java 常用类

##### Object

1. 11个方法
2. 5个：hashCode、equals、toString、clone、finalize，可重写，建议重写所有子类toString；
3. equals **默认==比较**，通过重写比如String比较字符，类比较内容
4. hashCode key-value(地址和int散列码)，用于比较是否相同。由于碰撞可能不同对象有相同的散列码，**再通过equals判断内部内容是否相等**。减少了equals调用。
5. 反过来一样，equals相等则hashCode也要相同，因此**重写equals也必须重写hashCode**。**同步**

##### String

