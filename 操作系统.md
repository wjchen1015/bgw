# 操作系统

## 进程

关注点：

1. 进程的**状态**（创建、就绪（就绪挂起）、运行、阻塞（阻塞挂起）、终止），进程状态机（创建，终止进程的过程，**阻塞（I/O，等待资源，ctrl z，sleep）**，唤醒进程的过程），PCB块的内容（标识：id，用户id，控制：状态，优先级，资源：内存地址，文件列表，I/O设备，CPU：**程序计数器，寄存器**），进程上下文（寄存器和程序计数器），PCB队列（状态转换即**队列增删和PCB填充删除**）
2. 线程的状态（就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系），线程内容（共享代码段、数据段、文件，维护寄存器和栈）
3. 线程的动机：如何**通信**，**共享数据**；维护进程的系统**开销较大**，如创建进程时，分配资源、建立 PCB；终止进程时，回收资源、撤销 PCB；进程切换时，**保存当前进程的状态信息**；例如：视频需要读取——解压——播放，我们需要共享数据并并发执行。
4. 进程线程的差异：
   1. 进程资源分配（内存和文件），线程cpu调度单位；
   2. 进程完整资源，线程独享寄存器和栈，具有相同的地址空间共享虚拟内存；
   3. 就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系；
   4. 线程能减少并发执行的时间和空间开销；
   5. 线程之间的数据交互效率更高；
   6. 线程时空优越；
   7. 不同进程所属线程切换等价于进程切换，同一进程线程切换只需切换寄存器和栈等私有资源。

---

## 线程

关注点：

1. 用户线程，内核线程的区别：
   1. 用户线程由用户态的线程管理库实现，**对于操作系统TCB是透明的**，管理和调度（**创建、终止、同步和调度**）均有用户态的线程管理库实现。**多对一的关系**；
   2. 内核线程是由操作系统管理的，线程对应的 TCB 自然是放在操作系统里的，这样线程的创建、终止和管理都是由操作系统负责。**一对一关系**。
2. 用户线程的优缺点：
   1. 每个进程都需要有它私有的**线程控制块（TCB）**列表，用来跟踪记录它各个线程状态信息（PC、栈指针、寄存器），TCB 由用户级线程库函数来维护，**可用于不支持线程技术的操作系统**；
   2. 用户线程的切换也是由线程库函数来完成的，**无需用户态与内核态的切换，所以速度特别快**；
   3. 由于操作系统不参与线程的调度，如果一**个线程发起了系统调用而阻塞，那进程所包含的用户线程都不能执行了**（相当于进程阻塞）。
   4. 当一个线程开始运行后，除非它主动地交出 CPU 的使用权，否则它所在的进程当中的其他线程无法运行，因为**用户态的线程没法打断当前运行中的线程**（线程调度不由操作系统执行），它没有这个特权，只有操作系统才有，但是用户线程不是由操作系统管理的。
   5. 由于时间片分配给进程，故与其他进程比，在多线程执行时，**每个线程得到的时间片较少，执行会比较慢**；
3. 内核线程的优缺点：
   1. 在一个进程当中，如果某个内核线程发起系统调用而被阻塞，并**不会影响其他内核线程**的运行（一对一，不会阻塞进程）；
   2. 分配给线程，**多线程的进程获得更多的 CPU 运行时间**；
   3. **只能支持内核线程的操作系统中**，由内核来维护进程和线程的上下文信息，如 PCB 和 TCB；
   4. 线程的创建、终止和切换都是通过系统调用的方式来进行，因此对于系统来说，**系统开销比较大**，（用户态和内核态的切换）；
4. 轻量级进程：一个内核线程支持**的用户线程**，通俗理解就是在用户空间构建的内核线程的代理，分为几种情况：
   1. 1：1，一个用户线程对应一个轻量级进程，一对一关系，类似于内核线程的概念，能够并行执行线程，但是多个用户线程需要多个内核线程，开销大；
   2. N：1，一个LWP对应多个用户线程，多对一关系，类似用户线程，TCB是透明的，阻塞用户线程会引起整个进程阻塞；
   3. M：N，多个LWP对应多个用户线程，当同一个LWP的线程切换不会在用户态和内核态切换，减小开销，同时阻塞线程并不会阻塞进程。
   4. 1：1+M：N，结合第1和3两种情况。

---

## 内存

### 虚拟内存的作用（局部性空间扩充、进程地址空间隔离、独立控制更安全）

- 第一，虚拟内存可以使得进程对运行内存超过物理内存大小，因为程序运行**符合局部性原理**，CPU 访问内存会有很明显的重复访问的倾向性，对于那些没有被经常使用到的内存，我们可以把它换出到物理内存之外，比如**硬盘上的 swap 区域**。
- 第二，由于**每个进程都有自己的页表**，所以每个进程的虚拟内存空间就是相互独立的。进程也没有办法访问其他进程的页表，所以这些页表是私有的，这就解决了**多进程之间地址冲突的问题**。
- 第三，页表里的页表项中除了物理地址之外，还有**一些标记属性的比特**，比如控制一个页的读写权限，标记该页是否存在等。在内存访问方面，**操作系统提供了更好的安全性**。

---

### malloc 分配内存

1. 内存的结构，第一层次可以分为用户空间和内核空间，用户空间分为栈、文件映射区、堆、BSS段、数据段、代码段、保留区。
2. 用户空间是用户进程能够访问的，内核空间只有内核能够访问。
3. 用户空间独占，内核空间共享。
4. 切换内核和用户态需要保存上下文和恢复上下文，开销大，执行完复制结果。
5. 库函数和shell通过系统调用（操作系统的最小功能单位）进入内核态，异常和外设中断也会切换为内核态。

两个系统调用，**brk（128KB，堆）和mmap（大于128KB，文件映射区）**

#### malloc() 分配的是物理内存吗？

1. 不是，是虚拟内存
2. 只有**访问时**，发现页不在内存中，**缺页中断**，建立虚拟内存和物理内存之间的映射关系。

#### malloc(1) 会分配多大的虚拟内存？

会预分配更大的空间作为内存池。

#### free 释放内存，会归还给操作系统吗？

free 内存后堆内存**还存在**，在内存池中，待下次使用**，是针对 malloc 通过 brk()** 方式申请的内存的情况。

如果 malloc **通过 mmap 方式申请的内存，free 释放内存后就会归还**给操作系统。

#### 为什么不全部使用 mmap 来分配内存？

频繁通过 mmap 分配的内存话，不仅每次都会发生**运行态的切换，还会发生缺页中断**（在第一次访问虚拟地址后），这样会导致 CPU 消耗较大。

为了改进这两个问题，malloc 通过 brk() 系统调用在堆空间申请内存的时候，由于堆空间是连续的，所以直接**预分配更大的内存**来作为内存池，当内存释放的时候，就缓存在内存池中。

等下次在申请内存的时候，就直接从内存池取出对应的内存块就行了，而且可能这个内存块的**虚拟地址与物理地址的映射关系还存在，这样不仅减少了系统调用的次数，也减少了缺页中断的次数，这将大大降低 CPU 的消耗**。

#### 既然 brk 那么牛逼，为什么不全部使用 brk 来分配？

如果下次申请的内存大于 内存池的碎片，没有可用的空闲内存空间，必须向 OS 申请，**实际使用内存继续增大**。

因此，随着系统频繁地 malloc 和 free ，尤其**对于小块内存，堆内将产生越来越多不可用的碎片，导致“内存泄露”**。

#### free() 函数只传入一个内存地址，为什么能知道要释放多大的内存？

malloc 返回给用户态的内存起始地址**比进程的堆空间起始地址多了 16 字节**，16 字节就是保存了该内存块的描述信息，比如有该内存块的大小。内存地址向左偏移 16 字节，分析出当前的内存块的大小。

---

### 内存满了？

问题场景：**缺页中断**（访问时），缺页中断处理函数会看是否有空闲的物理内存，如果有，就直接分配物理内存，并建立虚拟内存与物理内存之间的映射关系。

如果**没有空闲的物理内存**，那么内核就会开始进行**回收内存**的工作，回收的方式主要是两种：**直接内存回收和后台内存回收**。

流程：1. 缺页中断；2. 无空闲；3. 后台内存回收；4. （无空闲）直接内存回收；5.（无空闲）OOM。

1. **后台内存回收**：唤醒 kswapd 内核线程，异步回收，不会阻塞进程。
2. 直接内存回收：跟不上进程内存申请的速度，就会开始直接回收，这个回收内存的过程是**同步**的，会阻塞进程的执行。
3. OOM：根据算法选择一个占用物理内存较高的进程，然后将其杀死，以便释放内存资源，如果物理内存依然不足，OOM Killer 会继续杀死占用物理内存较高的进程，**直到释放足够的内存位置**。（-1000到1000，设置-1000就是不可杀死的）

#### 哪些内存可以被回收？

1. **文件页**（File-backed Page）：内核缓存的磁盘数据（Buffer）和内核缓存的文件数据（Cache）都叫作文件页。**回收干净页的方式是直接释放内存，回收脏页的方式是先写回磁盘后再释放内存**。
2. **匿名页**（Anonymous Page）：这部分内存没有实际载体，不像文件缓存有硬盘文件这样一个载体，比如堆、栈数据等。它们**回收的方式是通过 Linux 的 Swap 机制**，Swap 会把不常访问的内存先写到磁盘中，然后释放这些内存，给其他更需要的进程使用。

#### 回收内存带来的性能影响

一般建议 swappiness 设置为 0（默认值是 60），这样在回收内存的时候，会更倾向于文件页的回收，但是并不代表不会回收匿名页。

![img](https://img-blog.csdnimg.cn/166bc9f5b7c545d89f1e36ab8dd772cf.png)

---

### 在 4GB 物理内存的机器上，申请 8G 内存会怎么样

- 操作系统是 32 位的，还是 64 位的？
- 申请完 8G 内存后**会不会被使用**？
- 操作系统**有没有使用 Swap 机制**？（匿名页，IO开销大）

**Tips：所有的虚拟内存只有在访问时在需要建立联系，考虑的情况应该是内存在malloc后被访问了。**

---

#### 不同位数系统

**32 位操作系统，进程最多只能申请 3 GB 大小的虚拟内存空间**，所以进程申请 8GB 内存的话，在申请虚拟内存阶段就会失败。

64 位操作系统，**进程可以使用 128 TB 大小的虚拟内存空间**，所以进程申请 8GB 内存是没问题的，因为进程申请内存是申请虚拟内存，只要不读写这个虚拟内存，操作系统就不会分配物理内存。

**overcommit_memory** 参数 控制malloc申请内存，

1. 默认0，允许overcommit，但过于明目张胆的overcommit会被拒绝，比如malloc一次性申请的内存大小就超过了系统总内存。
2. 1 来者不拒
3. 2 不允许overcommit。

在设置了 overcommit_mermory 1 后，即使 malloc 申请的是虚拟内存，只要不去访问就不会映射到物理内存，但是申请虚拟内存的过程中，还是使用到了物理内存（比如**内核保存虚拟内存的数据结构，也是占用物理内存的**），如果你的主机是只有 2GB 的物理内存的话，**大概率会触发 OOM**。

直接内存回收之后，也无法回收出一块空间供这个进程使用，这个时候就会触发 OOM，给所有能杀死的进程打分，分数越高的进程越容易被杀死。

在这里当然是这个进程得分最高，那么操作系统就**会将这个进程杀死，所以最后会出现 killed**，而不是Cannot allocate memory。

---

#### Swap 机制的作用

如果申请物理内存大小超过了空闲物理内存大小，就要看操作系统有没有开启 Swap 机制：

- 如果没有开启 Swap 机制，程序就会直接 OOM；
- 如果有开启 Swap 机制，程序可以正常运行。

当**系统的物理内存不够用的时候**，就需要将物理内存中的一部分空间释放出来，以供当前运行的程序使用。

**当内存使用存在压力的时候**，会开始触发内存回收行为，会把这些不常访问的内存先写到磁盘中，然后释放这些内存，给其他更需要的进程使用。

- **内存不足**：当系统需要的内存超过了可用的物理内存时，内核会将内存中不常使用的内存页交换到磁盘上为当前进程让出内存，保证正在执行的进程的可用性，这个**内存回收的过程是强制的直接内存回收**（Direct Page Reclaim）。直接内存回收是同步的过程，会阻塞当前申请内存的进程。
- **内存闲置**：应用程序在启动阶段使用的大量内存在启动后往往都不会使用，通过后台运行的**守护进程（kSwapd）**，我们可以将这部分只使用一次的内存交换到磁盘上为其他内存的申请预留空间。kSwapd 是 Linux 负责页面置换（Page replacement）的守护进程，它也是负责交换闲置内存的主要进程，它会在[空闲内存低于一定水位 (opens new window)](https://xiaolincoding.com/os/3_memory/mem_reclaim.html#尽早触发-kSwapd-内核线程异步回收内存)时，回收内存页中的空闲内存保证系统中的其他进程可以尽快获得申请的内存。kSwapd 是后台进程，所以**回收内存的过程是异步的**，不会阻塞当前申请内存的进程。

Linux 提供了两种不同的方法启用 Swap，分别是 **Swap 分区（Swap Partition）和 Swap 文件（Swapfile）**

分区给匿名页。

---

### 预读失效和缓存污染

预读是基于时间与空间局部性的一个行为，通常是将相近的文件或者数据提前加载到内存中，例如在linux中，访问磁盘3KB文件（block为4KB），会提前读取4-8，8-12，12-16三个块加载到内存，多申请了3个page。**减少了 磁盘 I/O 次数，提高系统磁盘 I/O 吞吐量**。

#### 预读失效

缓存**提前加载进来的页，并没有被访问**，相当于这个预读工作是白做了，这个就是**预读失效**。

**影响：**内存会淘汰末尾的页，当前预读的页如果不是热点数据，将会挤占热点数据的内存空间，降低缓存命中率，增加了I/O的频率。

解决缓存失效的方法：

1. linux：linux将LRU使用的链表分为活跃和非活跃链表，预读页被置于非活跃的链表头，当它们被访问时，会转移到活跃链表表头，活跃表尾下方只非活跃表头，淘汰非活跃表尾。
2. mysql：将其分为young和old区域（一个链表），默认（63：37），预读也被放置buffer pool的old表头，处理与linux一致。

#### 缓存污染

使用「只要数据被访问一次，就将数据加入到活跃 LRU 链表头部（或者 young 区域）」

大量数据都会被加入到「活跃 LRU 链表」里，然后之前缓存在活跃 LRU 链表（或者 young 区域）里的热点数据全部都被淘汰了，**如果这些大量的数据在很长一段时间都不会被访问的话，那么整个活跃 LRU 链表（或者 young 区域）就被污染了**。

预读不会挤占活跃空间，但是一旦访问便转移到活跃链表，这同样会淘汰热点数据。**（访问是一次随便而非频繁谨慎的操作）**。

热数据又被再次访问的时候，由于缓存未命中，就会产生大量的磁盘 I/O，系统性能就会急剧下降。

**避免缓存污染：提高进入到活跃 LRU 链表（或者 young 区域）的门槛**，就能有效地保证活跃 LRU 链表（或者 young 区域）里的热点数据不会被轻易替换掉。

##### 方式：

- **Linux 操作系统**：在内存页被访问**第二次**的时候，才将页从 inactive list 升级到 active list 里。
- **MySQL Innodb**：在内存页被访问**第二次**的时候，并不会马上将该页从 old 区域升级到 young 区域，因为还要进行**停留在 old 区域**的时间判断：
  - 如果第二次的访问时间与第一次访问的时间**在 1 秒内**（默认值），那么该页就**不会**被从 old 区域升级到 young 区域；
  - 如果第二次的访问时间与第一次访问的时间**超过 1 秒**，那么该页就**会**从 old 区域升级到 young 区域；

---

### Linux虚拟内存管理

---

#### 那么到底什么是虚拟内存地址 ？

**虚拟地址可以*人为*的变来变去**，但是物理地址永远是不变，维度和经度可以定位物理地址，虚拟地址是长沙，成都（这些是可变的，也可以叫长砂）。

虚拟地址==现实地址的格式，页目录项/页表项/页内偏移==湖南省/长沙市/岳麓区...。

---

#### 为什么要引入虚拟内存而不直接使用物理内存 ？

直接使用物理内存：

1. 无法满足进程的内存要求（e.g. 物理2G，申请2.5G）；
2. 无法解决多进程间的地址冲突；
3. 不好独立管理控制进程内存。

**程序局部性原理表现为：时间局部性和空间局部性**。时间局部性是指如果程序中的某条指令一旦执行，则不久之后该指令可能再次被执行；如果某块数据被访问，则不久之后该数据可能再次被访问。空间局部性是指一旦程序访问了某个存储单元，则不久之后，其附近的存储单元也将被访问。

程序局部性，进程真正需要的物理内存其实是很少的一部分。

---

#### 虚拟内存空间？

虚拟内存分别为：

- 用于存放进程程序二进制文件中的机器指令的**代码段**
- 用于存放程序二进制文件中定义的**全局变量和静态变量的数据段和 BSS 段**（未初始）。
- 用于在程序运行过程中**动态申请内存的堆**。
- 用于存放**动态链接库以及内存映射区域**（mmap）的**文件映射与匿名映射区**。
- 用于存放函数调用过程中的**局部变量和函数参数的栈**。

---

#### Linux虚拟内存空间？

##### 32位

![image.png](https://img-blog.csdnimg.cn/img_convert/ffb6e1727e2289f142f6a2a6291cd68c.png)

0x0000 0000 —— 0x0804 8000 保留区，不可访问，例如C语言的NULL指向。

会记录 BSS 段的大小，在加载进内存时会生成一段 0 填充的内存空间。

内核中使用 start_brk 标识堆的起始位置，brk 标识堆当前的结束位置。

堆空间的上边是一段待分配区域，用于扩展堆空间的使用。接下来就来到了文件映射与匿名映射区域。进程运行时所依赖的动态链接库中的代码段，数据段，BSS 段就加载在这里。还有我们调用 mmap 映射出来的一段虚拟内存空间也保存在这个区域。**注意：在文件映射与匿名映射区的地址增长方向是从高地址向低地址增长**。

栈空间，在这里会保存函数运行过程所需要的局部变量以及函数参数等函数调用信息。**栈空间中的地址增长方向是从高地址向低地址增长**。

内核中使用 start_stack 标识栈的起始位置，RSP 寄存器中保存栈顶指针 stack pointer，RBP 寄存器中保存的是栈基地址。

##### 64 位

目前的 64 位系统下**只使用了 48 位**来描述虚拟内存空间，寻址范围为 2^48 ，所能表达的虚拟内存空间为 256TB。

![image.png](https://img-blog.csdnimg.cn/img_convert/4956918c43e186d49df7b9802f080de8.png)

**用户空间，高16位全为0，内核空间高16位全为1**，用于判断内存访问合法。

##### 32 vs. 64

主要不同的地方有三点：

1. 就是前边提到的由高 16 位空闲地址造成的 **canonical address** 空洞。在这段范围内的虚拟内存地址是不合法的，因为它的高 16 位既不全为 0 也不全为 1，不是一个 canonical address，所以称之为 canonical address 空洞。
2. 在**代码段跟数据段的中间还有一段不可以读写的保护段**，它的作用是防止程序在读写数据段的时候越界访问到代码段，这个保护段可以**让越界访问行为直接崩溃**，防止它继续往下运行。
3. 用户态虚拟内存空间与内核态虚拟内存空间分别占用 128T，其中低128T 分配给用户态虚拟内存空间，高 128T 分配给内核态虚拟内存空间。

---

#### 内核如何管理进程虚拟内存？

**进程描述符 task_struct** 结构中，有一个专门描述进程虚拟地址空间的**内存描述符 mm_struct** 结构。

调用 fork() 函数，拷贝父进程的相关资源到新进程的 task_struct 结构里，其中就包括拷贝父进程的虚拟内存空间 mm_struct 结构。

在**copy_mm** 函数完成了子进程虚拟内存空间 mm_struct 结构的的创建以及初始化。

 **fork() 函数创建出的子进程，虚拟内存空间以及相关页表相当于父进程虚拟内存空间的一份拷贝**，直接从父进程中拷贝到子进程中。

通过 **vfork 或者 clone** 系统调用创建出的子进程**（共享等同于线程）**，父进程的虚拟内存空间以及相关页表直接赋值给子进程，父进程和子进程的虚拟内存空间就变成共享的了。

内核**线程**和用户态**线程**的区别就是内核线程没有相关的内存描述符 mm_struct ，内核线程对应的 task_struct 结构中的 mm 域指向 Null，所以内核线程之间调度是不涉及地址空间切换的。

聪明的内核会将调度之前的上一个用户态进程的虚拟内存空间 mm_struct 直接赋值给内核线程，因为内核线程不会访问用户空间的内存，它**仅仅只会访问内核空间的内存**（不同的用户空间其实无所谓），所以**直接复用上一个用户态进程的虚拟地址空间就可以避免为内核线程分配 mm_struct 和相关页表的开销**，以及避免内核线程之间调度时地址空间的切换开销。

---

##### 划分用户态和内核态虚拟内存空间

进程的内存描述符 **mm_struct 结构体中的 task_size 变量**，task_size 定义了用户态地址空间与内核态地址空间之间的分界线。

32位：task_size:3G，page_offset：0xC000 000

64位：task_size_max() 的计算逻辑中 1 左移 47 位得到的地址是 0x0000800000000000，然后减去一个 **PAGE_SIZE** （默认为 4K），就是 0x00007FFFFFFFF000，共 128T。**（有关页大小）**

---

##### 布局进程虚拟内存空间

![image.png](https://img-blog.csdnimg.cn/img_convert/8e6efc5f2c39a39959c337077359a824.png)

```c++
struct mm_struct {
    unsigned long task_size;    /* size of task vm space */
    unsigned long start_code, end_code, start_data, end_data;
    unsigned long start_brk, brk, start_stack;
    unsigned long arg_start, arg_end, env_start, env_end;
    unsigned long mmap_base;  /* base of mmap area */
    unsigned long total_vm;    /* Total pages mapped */
    unsigned long locked_vm;  /* Pages that have PG_mlocked set */
    unsigned long pinned_vm;  /* Refcount permanently increased */
    unsigned long data_vm;    /* VM_WRITE & ~VM_SHARED & ~VM_STACK */
    unsigned long exec_vm;    /* VM_EXEC & ~VM_WRITE & ~VM_STACK */
    unsigned long stack_vm;    /* VM_STACK */

       ...... 省略 ........
}
```

start_code 和 end_code 定义代码段的起始和结束位置，程序编译后的二进制文件中的机器码被加载进内存之后就存放在这里。

start_data 和 end_data 定义数据段的起始和结束位置，二进制文件中存放的全局变量和静态变量被加载进内存中就存放在这里。

后面紧挨着的是 BSS 段，用于存放未被初始化的全局变量和静态变量，这些变量在加载进内存时会生成一段 0 填充的内存区域 （BSS 段）， **BSS 段的大小是固定的**，

下面就是 OS 堆了，在堆中内存地址的增长方向是由低地址向高地址增长， start_brk 定义堆的起始位置，brk 定义堆当前的结束位置。

在内存映射区内存地址的增长方向是由高地址向低地址增长，**mmap_base 定义内存映射区的起始地址。**进程运行时所依赖的**动态链接库**中的代码段，数据段，BSS 段以及我们调用 mmap 映射出来的一段虚拟内存空间就保存在这个区域。

start_stack 是栈的起始位置在 RBP 寄存器中存储，栈的结束位置也就是栈顶指针 stack pointer 在 RSP 寄存器中存储。在栈中内存地址的增长方向也是由高地址向低地址增长。

arg_start 和 arg_end 是参数列表的位置， env_start 和 env_end 是环境变量的位置。**它们都位于栈中的最高地址处。**

total_vm 表示在进程虚拟内存空间中总共与物理内存映射的页的总数（将虚拟内存与物理内存建立关联关系，并**不代表真正的分配物理内存**）。

locked_vm 就是被锁定不能换出的内存页总数，pinned_vm 表示既不能换出，也不能移动的内存页总数。

data_vm 表示数据段中映射的内存页数目，exec_vm 是代码段中存放**可执行文件的内存页数目**，stack_vm 是栈中所映射的内存页数目，这些变量均是表示进程虚拟内存空间中的虚拟内存使用情况。

![image.png](https://img-blog.csdnimg.cn/img_convert/2b2dbb2b6ea19871152a3bf6566df205.png)

---

##### 内存如何管理虚拟内存

使用结构体**vm_area_struct**

![image.png](https://img-blog.csdnimg.cn/img_convert/4956390184c51584798be1e5aaabedd1.png)

---

##### 访问权限和行为规范

**vm_page_prot** 偏向于定义底层内存管理架构中**页这一级别的访问控制权限**，它可以直接应用在底层页表中，它是一个具体的概念。

**vm_flags** 则偏向于定于**整个虚拟内存区域的访问权限以及行为规范**。

VM_SHARD 用于指定这块虚拟内存区域映射的物理内存是否可以在多进程之间共享，以便完成进程间通讯。

![image.png](https://img-blog.csdnimg.cn/img_convert/600ef23c454d9f3653ece44debaaf3a7.png)

---

##### 关联内存映射

虚拟内存区域可以**映射到物理内存上**，也可以**映射到文件中**，映射到物理内存上我们称之为匿名映射，映射到文件中我们称之为文件映射。

申请的是比较大块的内存（超过 128K）时，则会调用 mmap 在上图虚拟内存空间中的文件映射与匿名映射区创建出一块 VMA 内存区域（这里是匿名映射）。这块匿名映射区域就用 **struct anon_vma** 结构表示。

调用 mmap 进行**文件映射**时，**vm_file** 属性就用来关联被映射的文件。**vm_pgoff** 则表示映射进虚拟内存中的文件内容，在文件中的**偏移**。

在匿名映射中，vm_area_struct 结构中的 vm_file 就为 null，vm_pgoff 也就没有了意义。

---

##### 虚拟内存区域的相关操作

vm_ops 用来指向针对虚拟内存区域 VMA 的相关操作的**函数指针**。

- 当指定的虚拟内存区域被加入到进程虚拟内存空间中时，**open 函数**会被调用
- 当虚拟内存区域 VMA 从进程虚拟内存空间中被删除时，**close 函数**会被调用
- 当进程访问虚拟内存时，访问的页面不在物理内存中，可能是未分配物理内存也可能是被置换到磁盘中，这时就会产生**缺页异常**，**fault 函数**就会被调用。
- 当一个只读的页面将要变为可写时，**page_mkwrite 函数会被调用**。

---

##### 虚拟内存区域在内核中是如何被组织的

vm_next ，vm_prev 指针分别指向 VMA 节点所在**双向链表**中的后继节点和前驱节点，内核中的这个 VMA 双向链表是有顺序的，所有 VMA 节点**按照低地址到高地址的增长方向排序**。

在内核中，同样的内存区域 vm_area_struct **会有两种组织形式**，一种是**双向链表用于高效的遍历**，另一种就是**红黑树用于高效的查找**。

---

##### 二进制文件如何映射到虚拟内存空间中

程序代码编译之后生成ELF 格式的二进制文件中的布局，和我们前边讲的虚拟内存空间中的布局类似，也是**一段一段的，每一段包含了不同的元数据。**

**磁盘文件中的段我们叫做 Section，内存中的段我们叫做 Segment**，也就是内存区域。

Section会在**进程运行之前加载到**内存中并映射到内存中的 Segment。通常是**多个 Section 映射到一个 Segment。**

内核中**完成这个映射过程的函数是 load_elf_binary** ，这个函数的作用很大，加载内核的是它，启动第一个用户态进程 init 的是它，fork 完了以后，调用 exec 运行一个二进制程序的也是它。当 exec 运行一个二进制程序的时候，除了**解析 ELF 的格式**之外，另外一个重要的事情就是**建立上述提到的内存映射**。

- setup_new_exec 设置虚拟内存空间中的内存映射区域起始地址 mmap_base
- setup_arg_pages 创建并初始化栈对应的 vm_area_struct 结构。置 mm->start_stack 就是栈的起始地址也就是栈底，并将 mm->arg_start 是指向栈底的。
- elf_map 将 ELF 格式的二进制文件中.text ，.data，.bss 部分映射到虚拟内存空间中的代码段，数据段，BSS 段中。
- set_brk 创建并初始化堆对应的的 vm_area_struct 结构，设置 `current->mm->start_brk = current->mm->brk`，设置堆的起始地址 start_brk，结束地址 brk。 起初两者相等表示堆是空的。
- load_elf_interp 将进程依赖的动态链接库 .so 文件映射到虚拟内存空间中的内存映射区域
- 初始化内存描述符 mm_struct

---

#### 内核虚拟内存空间

---

##### 32 位体系内核虚拟内存空间布局

---

##### 直接映射区

位于最前边有一块 896M 大小的区域，我们称之为直接映射区或者线性映射区，地址范围为 3G -- 3G + 896m 。映射到 **0 - 896M 这块连续的物理内存上**。

内核在访问这段区域的时候**还是走的虚拟内存地址，内核也会为这块空间建立映射页表。**

在这段 896M 大小的物理内存中，前 1M 已经在系统启动的时候被系统占用，1M 之后的物理内存存放的是内核代码段，数据段，BSS 段（**这些信息起初存放在 ELF格式的二进制文件中，在系统启动的时候被加载进内存**）。

**进程相关的数据结构存放在直接映射区中**，当进程被创建完毕之后，在内核运行的过程中，会涉及内核栈的分配，**内核会为每个进程分配一个*固定大小的内核栈*（一般是两个页大小，依赖具体的体系结构），每个进程的整个调用链必须放在自己的内核栈中，内核栈也是分配在直接映射区。**

内核栈是固定大小的。内核栈的溢出危害非常巨大，它会直接悄无声息的覆盖相邻内存区域中的数据，破坏数据。

---



---

#### 什么又是物理内存地址 ？如何访问物理内存？

---
